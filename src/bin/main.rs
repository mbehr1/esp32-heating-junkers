// Todos:
// [] connect to homematic ip cloud and get data from there
// [] twai / can support
// [] show error/state on display, e.g. state of wifi, ip, internet connectivity
// [] check stack memory usage and add stack overflow handlers
// [] detect USB/JTAG and show "debug infos"?
// [] handle devices becoming stale, removed from event updates, not reachable...
// [] OTA update support
// [] manual override of heating settings via touch display
// [] update to esp-hal 1.0.0
// [x] retrigger getCurrentState and websocket connection after wifi connected/network ipv4 change...s
// [x] use hw accel esp-mbedtls with reqwless
// [x] reconnect to wifi after link down,... (weirld with Static and then not dhcp...?)
// [] lp core for e.g. watchdog / configure rtc for watchdog
// [] watchdog if wlan connection is not established for a longer time (or after startup)
// [] remove unwraps and handle errors properly
// [] cleanup not used features (e.g. from embassy-net etc)
// [] show last update time on display for the getCurrentState response as well (as like for events)

#![no_std]
#![no_main]
#![deny(
    clippy::mem_forget,
    reason = "mem::forget is generally not safe to do with esp_hal types, especially those \
    holding buffers for the duration of a data transfer."
)]
#![allow(clippy::unnecessary_fallible_conversions)] // can fail with heapless strings

use alloc::string::ToString;
use axs5106l::Axs5106l;
use core::cell::RefCell;
use defmt::{debug, info, warn};
use embassy_executor::Spawner;
use embassy_net::{DhcpConfig, Runner, Stack, StackResources};
use embassy_time::{Duration, Timer};
use embedded_charts::prelude::*;
use embedded_graphics::{
    geometry::AnchorPoint,
    pixelcolor::Rgb565,
    primitives::{PrimitiveStyle, Rectangle},
};
use embedded_hal_bus::spi::ExclusiveDevice;
use esp_hal::{
    clock::CpuClock,
    delay::Delay,
    gpio::{Level, Output, OutputConfig},
    i2c::master::{Config as ConfigI2C, I2c},
    rng::Rng,
    spi::{
        Mode,
        master::{Config, Spi},
    },
    time::{Instant, Rate},
    timer::timg::TimerGroup,
    twai,
};
use esp_radio::wifi::{ClientConfig, ModeConfig, WifiController, WifiDevice, WifiError};
use heapless::String;
use jiff::{
    Timestamp,
    tz::{self, TimeZone},
};
use panic_rtt_target as _;

use mipidsi::{
    Builder,
    interface::SpiInterface,
    models::ST7789,
    options::{ColorOrder, Orientation},
};

use reqwless::client::HttpClient;

extern crate alloc;

use hzg_roon_junkers::{
    display_handling::{draw_init_screen, draw_text, draw_text_7seg},
    heating::{HEATER_CONTROL, HEATING_TEXT_TO_DISPLAY, heating_task},
    homematic::{
        DEVICES, HMIPHOME, HmIpGetHostResponse, TIMESTAMP_LAST_HMIP_UPDATE, json_process_device,
        json_process_home, single_https_request, websocket_connection,
    },
};

// If you are okay with using a nightly compiler, you can use the macro provided by the static_cell crate: https://docs.rs/static_cell/2.1.0/static_cell/macro.make_static.html
macro_rules! mk_static {
    ($t:ty,$val:expr) => {{
        static STATIC_CELL: static_cell::StaticCell<$t> = static_cell::StaticCell::new();
        #[deny(unused_attributes)]
        let x = STATIC_CELL.uninit().write($val);
        x
    }};
}

static TZ: TimeZone = tz::get!("Europe/Berlin");

#[toml_cfg::toml_config]
struct ConfigToml {
    #[default("hostnameToUseForDHCP")]
    pub hostname: &'static str,
    #[default("ssidToConnectTo")]
    pub wifi_ssid: &'static str,
    #[default("wifiPasswordToUse")]
    pub wifi_password: &'static str,
    #[default("Display Title")]
    pub display_title: &'static str,
    // HMIP config:
    #[default("homematicip-python")]
    pub hmip_application_identifier: &'static str,
    #[default("1.0")]
    pub hmip_application_version: &'static str,
    #[default("none")]
    pub hmip_device_manufacturer: &'static str,
    #[default("Computer")]
    pub hmip_device_type: &'static str,
    #[default("Darwin")]
    pub hmip_os_type: &'static str,
    #[default("25.0.0")]
    pub hmip_os_version: &'static str,
    #[default("https://lookup.homematic.com:48335/getHost")]
    pub hmip_lookup_host: &'static str,
    #[default("23dig-accpointid")]
    pub hmip_accesspoint_id: &'static str,
    #[default("61dig-authtoken")]
    pub hmip_authtoken: &'static str,
    #[default("128dig-clientauth")]
    pub hmip_clientauth: &'static str,
}
// a variable CONFIGTOML of type ConfigToml is generated by the above macro

static mut RNG_INSTANCE: Option<Rng> = None;

#[unsafe(no_mangle)]
extern "C" fn random() -> core::ffi::c_ulong {
    unsafe {
        if let Some(ref mut rng) = RNG_INSTANCE {
            rng.random() as core::ffi::c_ulong
        } else {
            warn!("RNG_INSTANCE not initialized!");
            0
        }
    }
}

#[esp_rtos::main]
async fn main(spawner: Spawner) -> ! {
    // generator version: 0.6.0

    rtt_target::rtt_init_defmt!();

    let config = esp_hal::Config::default().with_cpu_clock(CpuClock::max());
    let peripherals = esp_hal::init(config);

    // RAM 512kb...
    esp_alloc::heap_allocator!(size: 160 /*72*/ * 1024); // 100kb roughly for TLS1.2..., 100kb for json responses
    esp_alloc::heap_allocator!(#[unsafe(link_section = ".dram2_uninit")] size: 65536); // How much heap do we got?

    let timg0 = TimerGroup::new(peripherals.TIMG0);
    let sw_interrupt =
        esp_hal::interrupt::software::SoftwareInterruptControl::new(peripherals.SW_INTERRUPT);
    esp_rtos::start(timg0.timer0, sw_interrupt.software_interrupt0);

    info!("Embassy initialized!");

    // MARK: init display

    // init display (1.47inch capacitive touch LCD display, 172Ã—320 resolution, 262K color with display chip Jadard JD9853 (compatible with ST7789? ) and touch chip AXS5106L )
    // LCD_CLK GPIO1
    // LCD_DIN GPIO2
    // LCD_CS GPIO14
    // LCD_DC GPIO15
    // LCD_RST GPIO22
    // LCD_BL GPIO23
    let mut lcd_bl = Output::new(peripherals.GPIO23, Level::Low, OutputConfig::default());
    let lcd_cs = Output::new(peripherals.GPIO14, Level::Low, OutputConfig::default());
    let lcd_dc = Output::new(peripherals.GPIO15, Level::Low, OutputConfig::default()); // level low according to example from https://github.com/almindor/mipidsi/blob/master/examples/spi-ili9486-esp32-c3/src/main.rs
    let mut lcd_rst = Output::new(peripherals.GPIO22, Level::Low, OutputConfig::default());
    lcd_rst.set_high(); // todo why not directly high? (taken from above example)

    // according to spec 16ns is min write cycle duration (<62.5MHz), lets try 40Mhz
    let display_spi = Spi::new(
        peripherals.SPI2,
        Config::default()
            .with_frequency(Rate::from_mhz(60))
            .with_mode(Mode::_0),
    );
    if display_spi.is_err() {
        warn!(
            "Failed to initialize SPI2 for display with error {:?}",
            display_spi.err()
        );
        Timer::after(Duration::from_secs(2)).await;
        panic!("Failed to initialize SPI2 for display");
    }

    let display_spi = display_spi.unwrap();

    // TODO Does it make sense to use DMA here?
    /*
        let dma_channel = peripherals.DMA_CH0;
        let (rx_buffers, rx_desc, tx_buffer, tx_desc) = dma_buffers!(2048);
        let dma_rx_buf = DmaRxBuf::new(rx_desc, rx_buffers).unwrap();
        let dma_tx_buf = DmaTxBuf::new(tx_desc, tx_buffer).unwrap();
    */
    let display_spi = display_spi
        .with_sck(peripherals.GPIO1)
        .with_mosi(peripherals.GPIO2); //      .with_dma(dma_channel)
    //      .with_buffers(dma_rx_buf, dma_tx_buf);

    let spi_device = ExclusiveDevice::new(display_spi, lcd_cs, embassy_time::Delay).unwrap();

    let mut buffer = alloc::boxed::Box::new([0_u8; 1 * 2048]); // even 20k makes no visible change

    let di = SpiInterface::new(spi_device, lcd_dc, buffer.as_mut_slice());

    let mut delay = Delay::new();
    let mut display = Builder::new(ST7789, di)
        .display_size(172, 320)
        .display_offset(34, 0) // framebuffer is 240x320, so offset x by 34 to center 172px wide display // so there is around 20k of "RAM" available :-)
        .color_order(ColorOrder::Bgr)
        .orientation(Orientation::new().flip_horizontal()) // with this the display is higher than wide, upper left is origin, usb connecctor is on the lower side
        .reset_pin(lcd_rst)
        .init(&mut delay)
        .unwrap();
    info!(
        "Display initialized. Size: {}Wx{}H",
        display.size().width,
        display.size().height
    );
    // no change visible! display.set_tearing_effect(mipidsi::options::TearingEffect::HorizontalAndVertical).unwrap();

    // MARK: Init touch axs5106l controller:
    // on i2c shared with IMU QMI8658 (IMU_SDA GPIO18, IMU_SCL GPIO19)
    // TP_SCL GPIO19
    // TP_SDA GPIO18
    // TP_RST GPIO20
    // TP_INT GPIO21
    let td_rst = Output::new(peripherals.GPIO20, Level::Low, OutputConfig::default());

    let config_i2c = ConfigI2C::default().with_frequency(Rate::from_khz(100));
    let i2c = I2c::new(peripherals.I2C0, config_i2c)
        .unwrap()
        .with_sda(peripherals.GPIO18)
        .with_scl(peripherals.GPIO19);

    let mut touch_driver = Axs5106l::new(i2c, td_rst, 172, 320, axs5106l::Rotation::Rotate0);
    match touch_driver.init(&mut delay) {
        Ok(_) => info!("AXS5106L touch controller initialized"),
        Err(_e) => warn!("Failed to initialize AXS5106L touch controller"),
    };

    lcd_bl.set_high(); // turn on backlight

    draw_init_screen(&mut display, CONFIG_TOML.display_title).unwrap();
    debug!("Display initialized with title and border");

    // MARK: init wifi
    let radio_init = mk_static!(
        esp_radio::Controller,
        esp_radio::init().expect("Failed to initialize Wi-Fi/BLE controller")
    );
    let (wifi_controller, interfaces) =
        esp_radio::wifi::new(radio_init, peripherals.WIFI, Default::default())
            .expect("Failed to initialize Wi-Fi controller");

    let wifi_interface = interfaces.sta;
    info!("Wi-Fi MAC address: {}", wifi_interface.mac_address());

    let rng = Rng::new(); // peripherals.RNG);
    let net_seed = rng.random() as u64 | ((rng.random() as u64) << 32);
    unsafe {
        RNG_INSTANCE = Some(rng);
    }
    //info!("Network seed: 0x{:016X}", net_seed);
    //info!("TLS seed:     0x{:016X}", tls_seed);

    // config network stack for DHCP:
    let mut dhcp_config = DhcpConfig::default();
    dhcp_config.hostname = Some(CONFIG_TOML.hostname.try_into().unwrap());

    let config = embassy_net::Config::dhcpv4(dhcp_config);
    // Init network stack
    let (stack, runner) = embassy_net::new(
        wifi_interface,
        config,
        mk_static!(StackResources<3>, StackResources::<3>::new()),
        net_seed,
    );

    /*
    // timings for 80MHz, but esp32c6 uses 40MHz! (but the brp is halfed later internally, so we can calc with 80MHz)
    let timing = match self {
            Self::B125K => TimingConfig {
                baud_rate_prescaler: 32,
                sync_jump_width: 3,
                tseg_1: 15,
                tseg_2: 4,
                triple_sample: false,
            },
            Self::B1000K => TimingConfig {
                baud_rate_prescaler: 4,
                sync_jump_width: 3,
                tseg_1: 15,
                tseg_2: 4,
                triple_sample: false,
            },
     */
    // Calc timing values for 10k baudrate
    // simply taken from B1000K and multiplied prescaler by 100
    // weird, doesn't seem to match with the calc!
    // from pure calc its:
    // bitrate = f_src  / brp * (1 + prop_seq + tseg1 + tseg2)
    // but prop_seq is not known here...

    // from https://gitlab.informatik.uni-bremen.de/fbrning/esp-idf/-/blob/v4.3.2/components/hal/include/hal/twai_types.h
    // #define TWAI_TIMING_CONFIG_10KBITS()    {.brp = 400, .tseg_1 = 15, .tseg_2 = 4, .sjw = 3, .triple_sampling = false}
    const TWAI_BAUDRATE: twai::BaudRate = twai::BaudRate::Custom(twai::TimingConfig {
        baud_rate_prescaler: 400, // prescaler
        sync_jump_width: 3,       // synchronization jump width
        tseg_1: 15,               // time segment 1
        tseg_2: 4,                // time segment 2
        triple_sample: false,
    });
    let can_config = twai::TwaiConfiguration::new(
        peripherals.TWAI0,
        peripherals.GPIO7,
        peripherals.GPIO8,
        TWAI_BAUDRATE,
        twai::TwaiMode::SelfTest,
    );

    // Spawn parallel tasks
    spawner.spawn(connection(wifi_controller)).unwrap();
    spawner.spawn(net_task(runner)).unwrap();
    spawner
        .spawn(cloud_connection_task(
            stack,
            peripherals.SHA,
            peripherals.RSA,
        ))
        .unwrap();
    spawner.spawn(heating_task(can_config)).unwrap();

    // MARK: main loop
    let mut cnt = 0u32;
    let mut angle_bg = None;
    let mut last_stack_link_state = None;
    let mut last_stack_ipv4_addr = None;

    let mut last_timestamp_hmip_update: Option<jiff::Timestamp> = None;
    let mut last_instant_home_update: Instant = Instant::EPOCH;
    let mut last_sum_last_status_update = 0i64;

    let mut last_heating_text = String::<16>::new();

    // we're short on stack? so better allocate on heap
    let mut ht_cur_temp_data: alloc::vec::Vec<SlidingWindowSeries<Point2D, 144>> =
        alloc::vec::Vec::with_capacity(6); // TODO const same len as DEVICES...
    let mut ht_control_data: SlidingWindowSeries<Point2D, 144> = SlidingWindowSeries::new();

    loop {
        //info!("Hello world #{}", cnt);
        Timer::after(Duration::from_millis(40)).await;
        cnt += 20; // 1 turn in 2s

        // progress alike circle/arc
        let angle_start = ((cnt % 360) as f32).deg();
        //let angle_end = angle_start + 30.0.deg();
        let angle_sweep = 100.0.deg();

        if let Some(angle_bg) = angle_bg {
            embedded_graphics::primitives::Arc::new(
                Point::new(172 - 25, 22),
                20,
                angle_bg,
                if angle_bg - angle_start < 0.0.deg() {
                    angle_bg - angle_start + 360.0.deg()
                } else {
                    angle_bg - angle_start
                },
            )
            .into_styled(PrimitiveStyle::with_stroke(Rgb565::BLACK, 1))
            .draw(&mut display)
            .unwrap();
        }

        embedded_graphics::primitives::Arc::new(
            Point::new(172 - 25, 22),
            20,
            angle_start,
            angle_sweep,
        )
        .into_styled(PrimitiveStyle::with_stroke(Rgb565::BLUE, 1))
        .draw(&mut display)
        .unwrap();
        angle_bg = Some(angle_start);

        if let Ok(Some(touches)) = touch_driver.get_touch_data() {
            for (i, touch) in touches.points.iter().enumerate() {
                info!("Touch {}: X: {}, Y: {}", i, touch.x, touch.y);
            }
        }

        // check for wifi link state changes
        let link_state = stack.is_link_up();
        if last_stack_link_state != Some(link_state) {
            info!("Network link state changed: {}", link_state);
            last_stack_link_state = Some(link_state);
        }
        let ipv4_addr = stack.config_v4();
        if last_stack_ipv4_addr != ipv4_addr {
            info!("Network IPv4 address changed: {}", ipv4_addr);
            last_stack_ipv4_addr = ipv4_addr;
        }

        // update the graph every sec:
        if cnt % 500 == 40 {
            let chart_ht_temps =
                LineChart::builder()
                    .line_color(Rgb565::BLUE)
                    .line_width(1)
                    .with_y_axis(
                        LinearAxis::new(15.0, 25.0, AxisOrientation::Vertical, AxisPosition::Left)
                            .with_style(AxisStyle::minimal().with_grid_lines(
                                LineStyle::dotted(Rgb565::CSS_LIGHT_GRAY).width(1),
                            )),
                    )
                    .build()
                    .unwrap();
            let chart_hc_temp = LineChart::builder()
                .line_color(Rgb565::CSS_ORANGE_RED)
                .line_width(1)
                .with_y_axis(
                    LinearAxis::new(10.0, 70.0, AxisOrientation::Vertical, AxisPosition::Left)
                        .with_style(AxisStyle::minimal()),
                )
                .build()
                .unwrap();
            let chart_area = Rectangle::new(Point::new(2, 30), Size::new(168, 60));

            // every 10mins we push a new point, so for 24hs we need 144 points
            // data.push(Point2D::new(0.0, 10.0)).unwrap();
            const UPDATE_FREQ: u32 = 200; // secs TODO: change back to 10mins (60*10) (200s = 8h for 144 points)
            if cnt % (500 * UPDATE_FREQ) == 40 {
                // every UPDATE_FREQ mins
                DEVICES.lock(|devices| {
                    let devices = devices.borrow();
                    for (i, device) in devices.iter().enumerate() {
                        if ht_cur_temp_data.len() < i + 1 {
                            // might add chart label,... here as well
                            ht_cur_temp_data.push(SlidingWindowSeries::new());
                        }
                        ht_cur_temp_data[i].push(Point2D::new(
                            (cnt / (500 * UPDATE_FREQ)) as f32,
                            device.valve_act_temp as f32,
                        ));
                    }
                });
                HEATER_CONTROL.lock(|hc| {
                    let hc = hc.borrow();
                    ht_control_data.push(Point2D::new(
                        (cnt / (500 * UPDATE_FREQ)) as f32,
                        hc.target_supply_temp_celsius(),
                    ));
                });

                let config: ChartConfig<Rgb565> = ChartConfig::default();
                let _ = ChartRenderer::clear_area(chart_area, Rgb565::BLACK, &mut display);
                for temp_data in ht_cur_temp_data.iter() {
                    let data = temp_data;
                    // sadly we do need to copy the data into a StaticDataSeries as LineChart.draw needs that...
                    let mut chart_data_tmp = StaticDataSeries::<Point2D, 256>::new();
                    for point in data.iter() {
                        let _ = chart_data_tmp.push(point);
                    }
                    let _ = chart_ht_temps.draw(&chart_data_tmp, &config, chart_area, &mut display);
                }
                // draw control temp as well
                {
                    let data = &ht_control_data;
                    let mut chart_data_tmp = StaticDataSeries::<Point2D, 256>::new();
                    for point in data.iter() {
                        let _ = chart_data_tmp.push(point);
                    }
                    let _ = chart_hc_temp.draw(&chart_data_tmp, &config, chart_area, &mut display);
                }
            }
        }

        if cnt % 200 == 180 {
            // every  0.4s (as text might be updated every 1s)
            HEATING_TEXT_TO_DISPLAY.lock(|heating_text| {
                let (heating_text, text_color, bg_color) = &*heating_text.borrow();
                if !(heating_text.cmp(&last_heating_text) == core::cmp::Ordering::Equal) {
                    last_heating_text.clear();
                    last_heating_text.push_str(heating_text.as_str()).unwrap();
                    let text_area = Rectangle::new(Point::new(5, 100), Size::new(160, 30));
                    let _ = draw_text_7seg(
                        heating_text.as_str(),
                        text_area,
                        *bg_color,
                        *text_color,
                        &mut display,
                    );
                }
            });
        }

        // check for home/weather updates
        if cnt % 1000 == 400 {
            // every 2s
            HMIPHOME.lock(|hmiphome| {
                if let Some(home) = &*hmiphome.borrow() {
                    if last_instant_home_update != home.uptime_last_update {
                        last_instant_home_update = home.uptime_last_update;
                        let text_area = Rectangle::new(Point::new(5, 140), Size::new(160, 20));
                        if let Ok(weather_text) = heapless::format!(100;
                            "Weather:{:.1}degC",
                            home.weather.temperature,
                        ) {
                            let _ = draw_text(
                                &weather_text,
                                text_area,
                                Rgb565::BLACK,
                                Rgb565::WHITE,
                                &mut display,
                            );
                        };
                        let text_area = Rectangle::new(Point::new(5, 170), Size::new(160, 20));
                        if let Ok(weather_text) = heapless::format!(100;
                            "{} {}",
                            home.weather.condition,
                            home.weather.daytime,
                        ) {
                            let _ = draw_text(
                                &weather_text,
                                text_area,
                                Rgb565::BLACK,
                                Rgb565::WHITE,
                                &mut display,
                            );
                        };
                    }
                }
            });
        }

        // compare last_timestamp_hmip_update and update display if changed
        if cnt % 1000 == 500 {
            // every 2s
            let mut tdp_did_change = false;
            TIMESTAMP_LAST_HMIP_UPDATE.lock(|tsp| {
                let tsp_borrow = tsp.borrow();
                if last_timestamp_hmip_update != *tsp_borrow {
                    last_timestamp_hmip_update = tsp_borrow.clone();
                    tdp_did_change = true;
                }
            });
            if tdp_did_change {
                let text_area = Rectangle::new(Point::new(5, 200), Size::new(160, 20));
                if let Some(tsp) = last_timestamp_hmip_update {
                    let local_time = tsp.to_zoned(TZ.clone());
                    //let date = local_time.date();
                    let time = local_time.time();
                    let time_text = time.to_string();
                    let _ = draw_text(
                        &time_text,
                        text_area,
                        Rgb565::BLACK,
                        Rgb565::WHITE,
                        &mut display,
                    );
                } else {
                    let _ = draw_text(
                        "No HMIP update!",
                        text_area,
                        Rgb565::BLACK,
                        Rgb565::WHITE,
                        &mut display,
                    );
                }
            }
        }

        // show list of devices on screen: (only if updates... detect via last_status_update max value)
        if cnt % 1000 == 0 {
            // every 2s
            DEVICES.lock(|devices| {
                let devices = devices.borrow();
                let sum_last_status_update: i64 =
                    devices.iter().map(|d| d.last_status_update).sum::<i64>();

                if sum_last_status_update != last_sum_last_status_update {
                    last_sum_last_status_update = sum_last_status_update;
                    // redraw device list
                    // how to remove old devices?
                    for device in devices.iter().enumerate() {
                        let text_rect = Rectangle::new(
                            display.bounding_box().anchor_point(AnchorPoint::BottomLeft)
                                - Point::new(-5, 17 + (17 * device.0) as i32),
                            Size::new(160, 16),
                        );
                        // use red color for text if heating
                        // use yellow color for text if low battery
                        // else use white color

                        if let Ok(text) = heapless::format!(40;
                        "HT{}:{:>4.1}/{:>4.1}C V{:>3.0}%",
                        device.0,
                        device.1.set_point_temp,
                        device.1.valve_act_temp,
                        device.1.valve_position*100.0,)
                        {
                            let text_color = if device.1.valve_position > 0.0 {
                                Rgb565::CSS_ORANGE_RED
                            } else if device.1.low_bat {
                                Rgb565::YELLOW
                            } else {
                                Rgb565::WHITE
                            };
                            let _ = draw_text(
                                &text,
                                text_rect,
                                Rgb565::BLACK,
                                text_color,
                                &mut display,
                            );
                        };
                    }
                }
            });
        }
    }
}

#[embassy_executor::task]
async fn cloud_connection_task(
    stack: Stack<'static>,
    sha: esp_hal::peripherals::SHA<'static>,
    rsa: esp_hal::peripherals::RSA<'static>,
) {
    info!("task 'cloud_connection_task' running...");

    // determine free heap before TLS init
    info!("Free heap before TLS: {} bytes", esp_alloc::HEAP.free());
    info!("Heap stats before TLS: {:?}", esp_alloc::HEAP.stats());

    let mut tls = esp_mbedtls::Tls::new(sha).unwrap().with_hardware_rsa(rsa);
    tls.set_debug(5);
    //info!("TLS self-test(SHA384) result: {:?}", tls.self_test(esp_mbedtls::TlsTest::Sha384, true));
    //info!("TLS self-test(AES) result: {:?}", tls.self_test(esp_mbedtls::TlsTest::Aes, true));
    info!("ssl_config_check result: {:x}", tls.ssl_config_check());
    let tls_ref = tls.reference();

    use embassy_net::tcp::client::{TcpClient, TcpClientState};
    let tcp_state = mk_static!(TcpClientState::<1, 16384, 16640>, TcpClientState::new());

    loop {
        // Wait for network to be ready
        loop {
            if stack.is_link_up() {
                if let Some(config) = stack.config_v4() {
                    info!("CC: network ready with IP: {:?}", config.address);
                    break;
                }
            }
            Timer::after(Duration::from_millis(500)).await;
        }
        info!("Network is ready, starting cloud connection...");

        // connect to homematic ip cloud and get data from there
        let config = reqwless::client::TlsConfig::new(
            reqwless::TlsVersion::Tls1_2,
            reqwless::Certificates::default(),
            tls_ref,
        );

        let tcp_client = TcpClient::new(stack, tcp_state);
        let dns_socket = embassy_net::dns::DnsSocket::new(stack);

        let mut client = HttpClient::new_with_tls(&tcp_client, &dns_socket, config);
        info!("HTTP client with TLS initialized");
        info!("Free heap after TLS: {} bytes", esp_alloc::HEAP.free());
        info!("Heap stats after TLS: {:?}", esp_alloc::HEAP.stats());

        let url_rest: RefCell<Option<heapless::String<64>>> = RefCell::new(None);
        let url_websocket: RefCell<Option<heapless::String<64>>> = RefCell::new(None);

        let process_gethost_response = |code, body: &mut [u8]| {
            info!("Processing getHost response with status code {}:", code);
            if let Ok(body_str) = core::str::from_utf8(body) {
                info!("Response body: {}", body_str);
            }
            // todo: unescape needed? can host names contain json escaped chars?
            match serde_json_core::from_slice::<HmIpGetHostResponse>(body) {
                Ok((resp, consumed)) => {
                    info!("Parsed JSON response, consumed {} bytes", consumed);
                    info!("urlREST: {}", resp.url_rest);
                    *url_rest.borrow_mut() = heapless::String::try_from(resp.url_rest).ok();
                    info!("urlWebSocket: {}", resp.url_websocket);
                    *url_websocket.borrow_mut() =
                        heapless::String::try_from(resp.url_websocket).ok();
                    // replace wss: with https:
                    if let Some(ref mut url_ws) = *url_websocket.borrow_mut() {
                        if url_ws.starts_with("wss:") {
                            let https_url =
                                heapless::format!(64; "https:{}", &url_ws.as_str()[4..])
                                    .unwrap_or_default();
                            *url_ws = https_url;
                            info!("Converted urlWebSocket to HTTPS URL: {}", url_ws);
                        }
                    }
                }
                Err(err) => {
                    warn!(
                        "Failed to parse JSON response: {}",
                        defmt::Debug2Format(&err)
                    );
                }
            };
        };

        let client_characteristics = heapless::format!(400; "{{\"clientCharacteristics\": {{\"apiVersion\": \"10\", \"applicationIdentifier\": \"{}\", \"applicationVersion\": \"{}\", \"deviceManufacturer\": \"{}\", \"deviceType\": \"Computer\", \"language\": \"de_DE\", \"osType\": \"{}\", \"osVersion\": \"{}\"}}, \"id\": \"{}\"}}",
        CONFIG_TOML.hmip_application_identifier,
        CONFIG_TOML.hmip_application_version,
        CONFIG_TOML.hmip_device_manufacturer,
        CONFIG_TOML.hmip_os_type,
        CONFIG_TOML.hmip_os_version,
        CONFIG_TOML.hmip_accesspoint_id).unwrap_or_default();

        let get_host_res = single_https_request(
            reqwless::request::Method::POST,
            CONFIG_TOML.hmip_lookup_host,
            &[
                ("Content-Type", "application/json"),
                ("Accept", "application/json"),
            ],
            client_characteristics.as_bytes(),
            process_gethost_response,
            &mut client,
        )
        .await;
        if get_host_res.is_err() {
            warn!("Error during getHost request: {:?}", get_host_res.err());
            // reset URLs
            *url_rest.borrow_mut() = None;
            *url_websocket.borrow_mut() = None;
        }

        // do we have a rest url? then open a session to that one:
        if let Some(url_rest) = &*url_rest.borrow() {
            info!("Got REST URL from getHost: {}", url_rest);
            let process_rest_response = |code, body: &mut [u8]| {
                info!(
                    "Processing REST response with status code {}:, body.len(): {}",
                    code,
                    body.len()
                );
                /*if let Ok(body_str) = core::str::from_utf8(body) {
                    info!("Response body: {}", body_str);
                }*/
                // use core_json streaming deserializer
                if let Ok(ref mut des) =
                    core_json::Deserializer::<&[u8], core_json::ConstStack<20>>::new(&body[..])
                {
                    if let Ok(mut val) = des.value() {
                        if let Ok(core_json::Type::Object) = val.kind() {
                            if let Ok(mut fields) = val.fields() {
                                loop {
                                    match fields.next() {
                                        Some(Ok(mut field)) => {
                                            // collect field key:
                                            let key: heapless::String<200> =
                                                field.key().filter_map(|k| k.ok()).collect();
                                            // info!("Field key: {}", key);
                                            match key.as_ref() {
                                                "home" => {
                                                    info!("Processing 'home' object");
                                                    let _ = json_process_home(field);
                                                }
                                                "devices" => {
                                                    // info!("Processing 'devices':");
                                                    // iterate over devices: (object keys are device ids)
                                                    if let Ok(mut devices) = field.value().fields()
                                                    {
                                                        while let Some(Ok(device)) = devices.next()
                                                        {
                                                            let _ = json_process_device(device);
                                                        }
                                                    }
                                                }
                                                "clients" | "groups" => {}
                                                _ => {
                                                    // clients, groups
                                                    warn!("Ignoring field key: {}", key);
                                                }
                                            }
                                        }
                                        Some(Err(e)) => {
                                            warn!(
                                                "Error iterating field: {:?}",
                                                defmt::Debug2Format(&e)
                                            );
                                            // dont break;
                                        }
                                        None => {
                                            break;
                                        }
                                    }
                                }
                            }
                            // iterate over the fields: (expect home, groups, devices, clients)
                        }
                    } else {
                        warn!("Failed to parse first JSON value");
                    }
                } else {
                    warn!("Failed to create core_json deserializer");
                }
            };

            // add /hmip/home/getCurrentState
            let mut url = url_rest.clone();
            url.push_str("/hmip/home/getCurrentState").unwrap();
            info!("Full REST URL for getCurrentState: {}", url);
            let _rest_res = single_https_request(
                reqwless::request::Method::POST,
                &url,
                &[
                    ("Content-Type", "application/json"), // ("Accept", "application/json"),
                    ("VERSION", "12"), // todo is 12 from the response from getHost?
                    ("AUTHTOKEN", CONFIG_TOML.hmip_authtoken),
                    ("CLIENTAUTH", CONFIG_TOML.hmip_clientauth),
                    ("ACCESSPOINT-ID", CONFIG_TOML.hmip_accesspoint_id),
                ],
                client_characteristics.as_bytes(), // br#"{"clientCharacteristics": {"apiVersion": "10", "applicationIdentifier": "homematicip-python", "applicationVersion": "1.0", "deviceManufacturer": "none", "deviceType": "Computer", "language": "de_DE", "osType": "Darwin", "osVersion": "25.0.0"}, "id": "3014F711A000506269927DA4"}"#.as_slice(),
                process_rest_response,
                &mut client,
            )
            .await;
            if _rest_res.is_err() {
                warn!(
                    "Error during getCurrentState request: {:?}",
                    _rest_res.err()
                );
                // continuing anyway to try websocket EVENT updates only... ? TODO!
            }
        } else {
            warn!("No REST URL obtained from getHost, cannot proceed");
        }

        if let Some(url_websocket) = &*url_websocket.borrow() {
            let process_binary_cb = |data: &mut [u8]| {
                info!("Received websocket binary data, len: {}", data.len());
                if let Ok(ref mut des) =
                    core_json::Deserializer::<&[u8], core_json::ConstStack<20>>::new(&data[..])
                {
                    if let Ok(val) = des.value() {
                        if let Ok(mut fields) = val.fields() {
                            while let Some(Ok(mut field)) = fields.next() {
                                let key: heapless::String<64> =
                                    field.key().filter_map(|k| k.ok()).collect();
                                match key.as_ref() {
                                    "events" => {
                                        info!("Processing 'events' object");
                                        if let Ok(mut events) = field.value().fields() {
                                            while let Some(Ok(mut event)) = events.next() {
                                                let event_key: heapless::String<10> =
                                                    event.key().filter_map(|k| k.ok()).collect();
                                                info!(" Processing event key: {}", event_key);
                                                if let Ok(mut event_fields) = event.value().fields()
                                                {
                                                    while let Some(Ok(mut event_field)) =
                                                        event_fields.next()
                                                    {
                                                        let event_field_key: heapless::String<100> =
                                                            event_field
                                                                .key()
                                                                .filter_map(|k| k.ok())
                                                                .collect();
                                                        match event_field_key.as_ref() {
                                                            "device" => {
                                                                let _ = json_process_device(
                                                                    event_field,
                                                                ); // TODO only if pushEventType is "DEVICE_CHANGED"? (assuming this comes always first...)
                                                            }
                                                            "home" => {
                                                                let _ =
                                                                    json_process_home(event_field);
                                                            }
                                                            _ => {
                                                                info!(
                                                                    "  Ignoring event field key: {}",
                                                                    event_field_key
                                                                );
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    "timestamp" => {
                                        let timestamp_ms =
                                            field.value().to_number().ok().and_then(|n| n.i64());
                                        if let Some(timestamp_ms) = timestamp_ms {
                                            //info!("  timestamp (ms): {}", timestamp_ms);
                                            let timestamp =
                                                Timestamp::from_millisecond(timestamp_ms).ok();
                                            // replace TIMESTAMP_LAST_HMIP_UPDATE
                                            TIMESTAMP_LAST_HMIP_UPDATE.lock(|tsp| {
                                                *tsp.borrow_mut() = timestamp;
                                            });
                                        }
                                        /*
                                        let time =
                                            Timestamp::from_millisecond(timestamp.unwrap_or(0))
                                                //.and_then(|t| Ok(t/* .to_zoned(TZ.clone())*/.strftime("%y%m%d %T"))).unwrap();
                                                .and_then(|t| {
                                                    Ok(t /* .to_zoned(TZ.clone())*/
                                                        .to_string())
                                                })
                                                .unwrap();
                                        info!("  timestamp: {}", &time.as_str());*/
                                    }
                                    "origin" | "accessPointId" => {}
                                    _ => {
                                        info!("Ignoring websocket field key: {}", key);
                                    }
                                }
                            }
                        } else {
                            warn!("Websocket data is not an object");
                        }
                    } else {
                        warn!("Failed to parse first JSON value from websocket data");
                    }
                } else {
                    warn!("Failed to create core_json deserializer for websocket data");
                }
            };

            // open websocket connection to url_websocket
            let _ws_res = websocket_connection(
                url_websocket,
                &[
                    ("AUTHTOKEN", CONFIG_TOML.hmip_authtoken),
                    ("CLIENTAUTH", CONFIG_TOML.hmip_clientauth),
                    ("ACCESSPOINT-ID", CONFIG_TOML.hmip_accesspoint_id),
                ],
                process_binary_cb,
                &mut client,
            )
            .await;
        } else {
            warn!("No WebSocket URL obtained from getHost, cannot proceed");
        }
        // sleep a bit before restarting the loop
        Timer::after(Duration::from_secs(5)).await;
        info!("Restarting cloud connection task loop...");
    }
    /* in header_buf:
    HTTP/1.1 200 OK
    Server: Apache-Coyote/1.1
    Set-Cookie: JSESSIONID=FAD164160D2DFC19F18E2A2F2C5E90ED; Path=/; Secure; HttpOnly
    X-Application-Context: application
    Content-Type: application/json;charset=UTF-8
    Content-Length: 223
    Date: Sun, 26 Oct 2025 10:02:34 GMT
     */
    // info!("end cloud_connection_task");
}

#[embassy_executor::task]
async fn connection(mut controller: WifiController<'static>) {
    info!("task 'connection' running...");
    info!("Device capabilities: {:?}", controller.capabilities());
    let mut was_connected_once = false;
    loop {
        match controller.is_connected() {
            Ok(true) => {
                // info!("Already connected to wifi");
                Timer::after(Duration::from_secs(2)).await;
                continue;
            }
            Ok(false) => {}
            Err(WifiError::Disconnected) => {
                info!("Wifi controller disconnected.");
                // fallthrough to reconnect
            }
            Err(e) => {
                warn!("Failed to get wifi connection state: {:?}", e);
                Timer::after(Duration::from_millis(3000)).await;
                continue;
            }
        }

        // not connected, check whether controller is started:
        if !matches!(controller.is_started(), Ok(true)) {
            let client_config = ModeConfig::Client(
                ClientConfig::default()
                    .with_ssid(CONFIG_TOML.wifi_ssid.try_into().unwrap())
                    .with_password(CONFIG_TOML.wifi_password.try_into().unwrap()),
            );
            controller.set_config(&client_config).unwrap();
            info!("Starting wifi");
            controller.start_async().await.unwrap();
            info!("Wifi started!: {:?}", controller.is_started());
        }
        info!("About to connect...");

        match controller.connect_async().await {
            Ok(_) => {
                info!("Wifi connected!");
                was_connected_once = true;
            }
            Err(e) => {
                info!("Failed to connect to wifi: {:?}", e);
                // lets stop controller here and try again:
                if !was_connected_once{ // TODO or if we do loop here for e.g. 1min? difficult to test...
                    info!("Stopping wifi controller to retry...");
                    if let Err(e) = controller.stop_async().await {
                        warn!("Failed to stop wifi controller: {:?}", e);
                    }
                }
                Timer::after(Duration::from_millis(5000)).await
            }
        }
    }
    //info!("end connection task");
}

#[embassy_executor::task]
async fn net_task(mut runner: Runner<'static, WifiDevice<'static>>) {
    info!("task 'net_task' running...");
    runner.run().await;
    //info!("end net_task");
}

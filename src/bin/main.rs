// Todos:
// [] turn display orientation according to inertia sensor
// [] detect USB/JTAG and show "debug infos"?
// [] twai / can support
// [] show error/state on display, e.g. state of wifi, ip, internet connectivity
// [] OTA update support
// [] lp core for e.g. watchdog?
// [] remove unwraps and handle errors properly
// [] cleanup not used features (e.g. from embassy-net etc)

#![no_std]
#![no_main]
#![deny(
    clippy::mem_forget,
    reason = "mem::forget is generally not safe to do with esp_hal types, especially those \
    holding buffers for the duration of a data transfer."
)]
#![allow(clippy::unnecessary_fallible_conversions)] // can fail with heapless strings

use axs5106l::Axs5106l;
use defmt::{info, warn};
use embassy_executor::Spawner;
use embassy_net::{DhcpConfig, Runner, StackResources};
use embassy_time::{Duration, Timer};
use embedded_graphics::{
    geometry::AnchorPoint,
    mono_font::{MonoTextStyle, ascii::FONT_8X13},
    pixelcolor::Rgb565,
    prelude::*,
    primitives::{PrimitiveStyle, PrimitiveStyleBuilder, StrokeAlignment},
    text::{Alignment, Text},
};
use embedded_hal_bus::spi::ExclusiveDevice;
use esp_hal::{
    clock::CpuClock,
    delay::Delay,
    gpio::{Level, Output, OutputConfig},
    i2c::master::{Config as ConfigI2C, I2c},
    rng::Rng,
    spi::{
        Mode,
        master::{Config, Spi},
    },
    time::Rate,
    timer::timg::TimerGroup,
};
use esp_radio::wifi::{ClientConfig, ModeConfig, WifiController, WifiDevice};
use panic_rtt_target as _;

use mipidsi::{
    Builder,
    interface::SpiInterface,
    models::ST7789,
    options::{ColorOrder, Orientation},
};

extern crate alloc;

#[toml_cfg::toml_config]
struct ConfigToml {
    #[default("hostnameToUseForDHCP")]
    pub hostname: &'static str,
    #[default("ssidToConnectTo")]
    pub wifi_ssid: &'static str,
    #[default("wifiPasswordToUse")]
    pub wifi_password: &'static str,
    #[default("Display Title")]
    pub display_title: &'static str,
}
// a variable CONFIGTOML of type ConfigToml is generated by the above macro

// This creates a default app-descriptor required by the esp-idf bootloader.
// For more information see: <https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/app_image_format.html#application-description>
esp_bootloader_esp_idf::esp_app_desc!();

// If you are okay with using a nightly compiler, you can use the macro provided by the static_cell crate: https://docs.rs/static_cell/2.1.0/static_cell/macro.make_static.html
macro_rules! mk_static {
    ($t:ty,$val:expr) => {{
        static STATIC_CELL: static_cell::StaticCell<$t> = static_cell::StaticCell::new();
        #[deny(unused_attributes)]
        let x = STATIC_CELL.uninit().write($val);
        x
    }};
}

#[esp_rtos::main]
async fn main(spawner: Spawner) -> ! {
    // generator version: 0.6.0

    rtt_target::rtt_init_defmt!();

    let config = esp_hal::Config::default().with_cpu_clock(CpuClock::max());
    let peripherals = esp_hal::init(config);

    esp_alloc::heap_allocator!(#[unsafe(link_section = ".dram2_uninit")] size: 65536); // How much heap do we got?

    let timg0 = TimerGroup::new(peripherals.TIMG0);
    let sw_interrupt =
        esp_hal::interrupt::software::SoftwareInterruptControl::new(peripherals.SW_INTERRUPT);
    esp_rtos::start(timg0.timer0, sw_interrupt.software_interrupt0);

    info!("Embassy initialized!");

    // MARK: init display

    // init display (1.47inch capacitive touch LCD display, 172Ã—320 resolution, 262K color with display chip Jadard JD9853 (compatible with ST7789? ) and touch chip AXS5106L )
    // LCD_CLK GPIO1
    // LCD_DIN GPIO2
    // LCD_CS GPIO14
    // LCD_DC GPIO15
    // LCD_RST GPIO22
    // LCD_BL GPIO23
    let mut lcd_bl = Output::new(peripherals.GPIO23, Level::Low, OutputConfig::default());
    let lcd_cs = Output::new(peripherals.GPIO14, Level::Low, OutputConfig::default());
    let lcd_dc = Output::new(peripherals.GPIO15, Level::Low, OutputConfig::default()); // level low according to example from https://github.com/almindor/mipidsi/blob/master/examples/spi-ili9486-esp32-c3/src/main.rs
    let mut lcd_rst = Output::new(peripherals.GPIO22, Level::Low, OutputConfig::default());
    lcd_rst.set_high(); // todo why not directly high? (taken from above example)

    // according to spec 16ns is min write cycle duration (<62.5MHz), lets try 40Mhz
    let display_spi = Spi::new(
        peripherals.SPI2,
        Config::default()
            .with_frequency(Rate::from_mhz(40))
            .with_mode(Mode::_0),
    );
    if display_spi.is_err() {
        warn!(
            "Failed to initialize SPI2 for display with error {:?}",
            display_spi.err()
        );
        Timer::after(Duration::from_secs(2)).await;
        panic!("Failed to initialize SPI2 for display");
    }

    let display_spi = display_spi.unwrap();
    let display_spi = display_spi
        .with_sck(peripherals.GPIO1)
        .with_mosi(peripherals.GPIO2);

    let spi_device = ExclusiveDevice::new(display_spi, lcd_cs, embassy_time::Delay).unwrap();

    let mut buffer = [0_u8; 512];

    let di = SpiInterface::new(spi_device, lcd_dc, &mut buffer);

    let mut delay = Delay::new();
    let mut display = Builder::new(ST7789, di)
        .display_size(172, 320)
        .display_offset(34, 0)
        .color_order(ColorOrder::Bgr)
        .orientation(Orientation::new().flip_horizontal()) // with this the display is higher than wide, upper left is origin, usb connecctor is on the lower side
        .reset_pin(lcd_rst)
        .init(&mut delay)
        .unwrap();
    info!(
        "Display initialized. Size: {}Wx{}H",
        display.size().width,
        display.size().height
    );

    // MARK: Init touch axs5106l controller:
    // on i2c shared with IMU QMI8658 (IMU_SDA GPIO18, IMU_SCL GPIO19)
    // TP_SCL GPIO19
    // TP_SDA GPIO18
    // TP_RST GPIO20
    // TP_INT GPIO21
    let td_rst = Output::new(peripherals.GPIO20, Level::Low, OutputConfig::default());

    let config_i2c = ConfigI2C::default().with_frequency(Rate::from_khz(100));
    let i2c = I2c::new(peripherals.I2C0, config_i2c)
        .unwrap()
        .with_sda(peripherals.GPIO18)
        .with_scl(peripherals.GPIO19);

    let mut touch_driver = Axs5106l::new(i2c, td_rst, 172, 320, axs5106l::Rotation::Rotate0);
    match touch_driver.init(&mut delay) {
        Ok(_) => info!("AXS5106L touch controller initialized"),
        Err(_e) => warn!("Failed to initialize AXS5106L touch controller"),
    };

    lcd_bl.set_high(); // turn on backlight

    display.clear(Rgb565::BLACK).unwrap();
    info!("Display cleared");
    let border_stroke = PrimitiveStyleBuilder::new()
        .stroke_color(Rgb565::BLUE)
        .stroke_width(1)
        .stroke_alignment(StrokeAlignment::Inside)
        .build();
    display
        .bounding_box()
        .into_styled(border_stroke)
        .draw(&mut display)
        .unwrap();

    let text = CONFIG_TOML.display_title;
    let character_style = MonoTextStyle::new(&FONT_8X13 /*FONT_6X10*/, Rgb565::WHITE);
    Text::with_alignment(
        text,
        display.bounding_box().anchor_point(AnchorPoint::TopCenter) + Point::new(0, 15),
        character_style,
        Alignment::Center,
    )
    .draw(&mut display)
    .unwrap();

    // MARK: init wifi
    let radio_init = mk_static!(
        esp_radio::Controller,
        esp_radio::init().expect("Failed to initialize Wi-Fi/BLE controller")
    );
    let (wifi_controller, interfaces) =
        esp_radio::wifi::new(radio_init, peripherals.WIFI, Default::default())
            .expect("Failed to initialize Wi-Fi controller");

    let wifi_interface = interfaces.sta;
    info!("Wi-Fi MAC address: {}", wifi_interface.mac_address());

    let rng = Rng::new(); // peripherals.RNG);
    let net_seed = rng.random() as u64 | ((rng.random() as u64) << 32);
    let tls_seed = rng.random() as u64 | ((rng.random() as u64) << 32);
    info!("Network seed: 0x{:016X}", net_seed);
    info!("TLS seed:     0x{:016X}", tls_seed);

    // config network stack for DHCP:
    let mut dhcp_config = DhcpConfig::default();
    dhcp_config.hostname = Some(CONFIG_TOML.hostname.try_into().unwrap());

    let config = embassy_net::Config::dhcpv4(dhcp_config);
    // Init network stack
    let (stack, runner) = embassy_net::new(
        wifi_interface,
        config,
        mk_static!(StackResources<3>, StackResources::<3>::new()),
        net_seed,
    );

    // Spawn parallel tasks
    spawner.spawn(connection(wifi_controller)).unwrap();
    spawner.spawn(net_task(runner)).unwrap();

    // MARK: main loop
    let mut cnt = 0u32;
    let mut angle_bg = None;
    let mut last_stack_link_state = None;
    let mut last_stack_ipv4_addr = None;
    loop {
        //info!("Hello world #{}", cnt);
        Timer::after(Duration::from_millis(40)).await;
        cnt += 20; // 1 turn in 2s

        // progress alike circle/arc
        let angle_start = ((cnt % 360) as f32).deg();
        //let angle_end = angle_start + 30.0.deg();
        let angle_sweep = 100.0.deg();

        if let Some(angle_bg) = angle_bg {
            embedded_graphics::primitives::Arc::new(
                Point::new(25, 32),
                40,
                angle_bg,
                if angle_bg - angle_start < 0.0.deg() {
                    angle_bg - angle_start + 360.0.deg()
                } else {
                    angle_bg - angle_start
                },
            )
            .into_styled(PrimitiveStyle::with_stroke(Rgb565::BLACK, 2))
            .draw(&mut display)
            .unwrap();
        }

        embedded_graphics::primitives::Arc::new(Point::new(25, 32), 40, angle_start, angle_sweep)
            .into_styled(PrimitiveStyle::with_stroke(Rgb565::GREEN, 2))
            .draw(&mut display)
            .unwrap();
        angle_bg = Some(angle_start);

        if let Ok(Some(touches)) = touch_driver.get_touch_data() {
            for (i, touch) in touches.points.iter().enumerate() {
                info!("Touch {}: X: {}, Y: {}", i, touch.x, touch.y);
            }
        }

        // check for wifi link state changes
        let link_state = stack.is_link_up();
        if last_stack_link_state != Some(link_state) {
            info!("Network link state changed: {}", link_state);
            last_stack_link_state = Some(link_state);
        }
        let ipv4_addr = stack.config_v4();
        if last_stack_ipv4_addr != ipv4_addr {
            info!("Network IPv4 address changed: {}", ipv4_addr);
            last_stack_ipv4_addr = ipv4_addr;
        }
    }
}

#[embassy_executor::task]
async fn connection(mut controller: WifiController<'static>) {
    info!("task 'connection' running...");
    info!("Device capabilities: {:?}", controller.capabilities());
    loop {
        match controller.is_connected() {
            Ok(true) => {
                // info!("Already connected to wifi");
                Timer::after(Duration::from_secs(2)).await;
                continue;
            }
            Ok(false) => {}
            Err(e) => {
                warn!("Failed to get wifi connection state: {:?}", e);
                Timer::after(Duration::from_millis(3000)).await;
                continue;
            }
        }

        // not connected, check whether controller is started:
        if !matches!(controller.is_started(), Ok(true)) {
            let client_config = ModeConfig::Client(
                ClientConfig::default()
                    .with_ssid(CONFIG_TOML.wifi_ssid.try_into().unwrap())
                    .with_password(CONFIG_TOML.wifi_password.try_into().unwrap()),
            );
            controller.set_config(&client_config).unwrap();
            info!("Starting wifi");
            controller.start_async().await.unwrap();
            info!("Wifi started!: {:?}", controller.is_started());
        }
        info!("About to connect...");

        match controller.connect_async().await {
            Ok(_) => info!("Wifi connected!"),
            Err(e) => {
                info!("Failed to connect to wifi: {:?}", e);
                Timer::after(Duration::from_millis(5000)).await
            }
        }
    }
    //info!("end connection task");
}

#[embassy_executor::task]
async fn net_task(mut runner: Runner<'static, WifiDevice<'static>>) {
    info!("task 'net_task' running...");
    runner.run().await;
    //info!("end net_task");
}

// Todos:
// [] connect to homematic ip cloud and get data from there
// [] twai / can support
// [] show error/state on display, e.g. state of wifi, ip, internet connectivity
// [] check stack memory usage and add stack overflow handlers
// [] detect USB/JTAG and show "debug infos"?
// [] OTA update support
// [] turn display orientation according to inertia sensor
// [] use hw accel esp-mbedtls with reqwless
// [] reconnect to wifi after link down,...
// [] lp core for e.g. watchdog / configure rtc for watchdog
// [] watchdog if wlan connection is not established for a longer time (or after startup)
// [] remove unwraps and handle errors properly
// [] cleanup not used features (e.g. from embassy-net etc)

#![no_std]
#![no_main]
#![deny(
    clippy::mem_forget,
    reason = "mem::forget is generally not safe to do with esp_hal types, especially those \
    holding buffers for the duration of a data transfer."
)]
#![allow(clippy::unnecessary_fallible_conversions)] // can fail with heapless strings

use axs5106l::Axs5106l;
use core::cell::RefCell;
use defmt::{info, warn};
use embassy_executor::Spawner;
use embassy_futures::select::{select, Either};
use embassy_net::{DhcpConfig, Runner, Stack, StackResources};
use embassy_sync::blocking_mutex::{Mutex, raw::CriticalSectionRawMutex};
use embassy_time::{Duration, Timer};
use embedded_graphics::{
    geometry::AnchorPoint,
    mono_font::{MonoTextStyle, ascii::FONT_8X13},
    pixelcolor::Rgb565,
    prelude::*,
    primitives::{PrimitiveStyle, PrimitiveStyleBuilder, Rectangle, StrokeAlignment},
    text::{Alignment, Text},
};
use embedded_hal_bus::spi::ExclusiveDevice;
use esp_hal::{
    clock::CpuClock,
    delay::Delay,
    gpio::{Level, Output, OutputConfig},
    i2c::master::{Config as ConfigI2C, I2c},
    rng::Rng,
    spi::{
        Mode,
        master::{Config, Spi},
    },
    time::Rate,
    timer::timg::TimerGroup,
};
use esp_radio::wifi::{ClientConfig, ModeConfig, WifiController, WifiDevice};
use panic_rtt_target as _;

use mipidsi::{
    Builder,
    interface::SpiInterface,
    models::ST7789,
    options::{ColorOrder, Orientation},
};
use reqwless::{client::HttpClient, request::RequestBuilder};
use serde::Deserialize;

extern crate alloc;

#[toml_cfg::toml_config]
struct ConfigToml {
    #[default("hostnameToUseForDHCP")]
    pub hostname: &'static str,
    #[default("ssidToConnectTo")]
    pub wifi_ssid: &'static str,
    #[default("wifiPasswordToUse")]
    pub wifi_password: &'static str,
    #[default("Display Title")]
    pub display_title: &'static str,
    // HMIP config:
    #[default("homematicip-python")]
    pub hmip_application_identifier: &'static str,
    #[default("1.0")]
    pub hmip_application_version: &'static str,
    #[default("none")]
    pub hmip_device_manufacturer: &'static str,
    #[default("Computer")]
    pub hmip_device_type: &'static str,
    #[default("Darwin")]
    pub hmip_os_type: &'static str,
    #[default("25.0.0")]
    pub hmip_os_version: &'static str,
    #[default("https://lookup.homematic.com:48335/getHost")]
    pub hmip_lookup_host: &'static str,
    #[default("23dig-accpointid")]
    pub hmip_accesspoint_id: &'static str,
    #[default("61dig-authtoken")]
    pub hmip_authtoken: &'static str,
    #[default("128dig-clientauth")]
    pub hmip_clientauth: &'static str,
}
// a variable CONFIGTOML of type ConfigToml is generated by the above macro

/// the devices we monitor:
#[derive(Debug)]
struct HeatingThermostat {
    id: heapless::String<50>,
    label: heapless::String<50>,
    last_status_update: i64,
    low_bat: bool,
    valve_position: f64,
    set_point_temp: f64,
    valve_act_temp: f64,
}
impl defmt::Format for HeatingThermostat {
    fn format(&self, fmt: defmt::Formatter) {
        defmt::write!(
            fmt,
            "HeatingThermostat {{ id: {}, label: {}, last_status_update: {}, low_bat: {}, valve_position: {}, set_point_temp: {}, valve_act_temp: {} }}",
            self.id,
            self.label,
            self.last_status_update,
            self.low_bat,
            self.valve_position,
            self.set_point_temp,
            self.valve_act_temp
        )
    }
}

// list of devices
// might better use an embassy signal or channel?
static DEVICES: Mutex<CriticalSectionRawMutex, RefCell<heapless::Vec<HeatingThermostat, 6>>> =
    Mutex::new(RefCell::new(heapless::Vec::new()));

// This creates a default app-descriptor required by the esp-idf bootloader.
// For more information see: <https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/app_image_format.html#application-description>
esp_bootloader_esp_idf::esp_app_desc!();

// If you are okay with using a nightly compiler, you can use the macro provided by the static_cell crate: https://docs.rs/static_cell/2.1.0/static_cell/macro.make_static.html
macro_rules! mk_static {
    ($t:ty,$val:expr) => {{
        static STATIC_CELL: static_cell::StaticCell<$t> = static_cell::StaticCell::new();
        #[deny(unused_attributes)]
        let x = STATIC_CELL.uninit().write($val);
        x
    }};
}

#[esp_rtos::main]
async fn main(spawner: Spawner) -> ! {
    // generator version: 0.6.0

    rtt_target::rtt_init_defmt!();

    let config = esp_hal::Config::default().with_cpu_clock(CpuClock::max());
    let peripherals = esp_hal::init(config);

    // RAM 512kb...
    esp_alloc::heap_allocator!(size: 180 /*72*/ * 1024); // 100kb roughly for TLS1.2..., 100kb for json responses
    esp_alloc::heap_allocator!(#[unsafe(link_section = ".dram2_uninit")] size: 65536); // How much heap do we got?

    let timg0 = TimerGroup::new(peripherals.TIMG0);
    let sw_interrupt =
        esp_hal::interrupt::software::SoftwareInterruptControl::new(peripherals.SW_INTERRUPT);
    esp_rtos::start(timg0.timer0, sw_interrupt.software_interrupt0);

    info!("Embassy initialized!");

    // MARK: init display

    // init display (1.47inch capacitive touch LCD display, 172Ã—320 resolution, 262K color with display chip Jadard JD9853 (compatible with ST7789? ) and touch chip AXS5106L )
    // LCD_CLK GPIO1
    // LCD_DIN GPIO2
    // LCD_CS GPIO14
    // LCD_DC GPIO15
    // LCD_RST GPIO22
    // LCD_BL GPIO23
    let mut lcd_bl = Output::new(peripherals.GPIO23, Level::Low, OutputConfig::default());
    let lcd_cs = Output::new(peripherals.GPIO14, Level::Low, OutputConfig::default());
    let lcd_dc = Output::new(peripherals.GPIO15, Level::Low, OutputConfig::default()); // level low according to example from https://github.com/almindor/mipidsi/blob/master/examples/spi-ili9486-esp32-c3/src/main.rs
    let mut lcd_rst = Output::new(peripherals.GPIO22, Level::Low, OutputConfig::default());
    lcd_rst.set_high(); // todo why not directly high? (taken from above example)

    // according to spec 16ns is min write cycle duration (<62.5MHz), lets try 40Mhz
    let display_spi = Spi::new(
        peripherals.SPI2,
        Config::default()
            .with_frequency(Rate::from_mhz(60))
            .with_mode(Mode::_0),
    );
    if display_spi.is_err() {
        warn!(
            "Failed to initialize SPI2 for display with error {:?}",
            display_spi.err()
        );
        Timer::after(Duration::from_secs(2)).await;
        panic!("Failed to initialize SPI2 for display");
    }

    let display_spi = display_spi.unwrap();
    let display_spi = display_spi
        .with_sck(peripherals.GPIO1)
        .with_mosi(peripherals.GPIO2);

    let spi_device = ExclusiveDevice::new(display_spi, lcd_cs, embassy_time::Delay).unwrap();

    let mut buffer = [0_u8; 512];

    let di = SpiInterface::new(spi_device, lcd_dc, &mut buffer);

    let mut delay = Delay::new();
    let mut display = Builder::new(ST7789, di)
        .display_size(172, 320)
        .display_offset(34, 0)
        .color_order(ColorOrder::Bgr)
        .orientation(Orientation::new().flip_horizontal()) // with this the display is higher than wide, upper left is origin, usb connecctor is on the lower side
        .reset_pin(lcd_rst)
        .init(&mut delay)
        .unwrap();
    info!(
        "Display initialized. Size: {}Wx{}H",
        display.size().width,
        display.size().height
    );

    // MARK: Init touch axs5106l controller:
    // on i2c shared with IMU QMI8658 (IMU_SDA GPIO18, IMU_SCL GPIO19)
    // TP_SCL GPIO19
    // TP_SDA GPIO18
    // TP_RST GPIO20
    // TP_INT GPIO21
    let td_rst = Output::new(peripherals.GPIO20, Level::Low, OutputConfig::default());

    let config_i2c = ConfigI2C::default().with_frequency(Rate::from_khz(100));
    let i2c = I2c::new(peripherals.I2C0, config_i2c)
        .unwrap()
        .with_sda(peripherals.GPIO18)
        .with_scl(peripherals.GPIO19);

    let mut touch_driver = Axs5106l::new(i2c, td_rst, 172, 320, axs5106l::Rotation::Rotate0);
    match touch_driver.init(&mut delay) {
        Ok(_) => info!("AXS5106L touch controller initialized"),
        Err(_e) => warn!("Failed to initialize AXS5106L touch controller"),
    };

    lcd_bl.set_high(); // turn on backlight

    display.clear(Rgb565::BLACK).unwrap();
    info!("Display cleared");
    let border_stroke = PrimitiveStyleBuilder::new()
        .stroke_color(Rgb565::BLUE)
        .stroke_width(1)
        .stroke_alignment(StrokeAlignment::Inside)
        .build();
    display
        .bounding_box()
        .into_styled(border_stroke)
        .draw(&mut display)
        .unwrap();

    let text = CONFIG_TOML.display_title;
    let character_style = MonoTextStyle::new(&FONT_8X13 /*FONT_6X10*/, Rgb565::WHITE);
    Text::with_alignment(
        text,
        display.bounding_box().anchor_point(AnchorPoint::TopCenter) + Point::new(0, 15),
        character_style,
        Alignment::Center,
    )
    .draw(&mut display)
    .unwrap();

    // MARK: init wifi
    let radio_init = mk_static!(
        esp_radio::Controller,
        esp_radio::init().expect("Failed to initialize Wi-Fi/BLE controller")
    );
    let (wifi_controller, interfaces) =
        esp_radio::wifi::new(radio_init, peripherals.WIFI, Default::default())
            .expect("Failed to initialize Wi-Fi controller");

    let wifi_interface = interfaces.sta;
    info!("Wi-Fi MAC address: {}", wifi_interface.mac_address());

    let rng = Rng::new(); // peripherals.RNG);
    let net_seed = rng.random() as u64 | ((rng.random() as u64) << 32);
    unsafe {
        RNG_INSTANCE = Some(rng);
    }
    //info!("Network seed: 0x{:016X}", net_seed);
    //info!("TLS seed:     0x{:016X}", tls_seed);

    // config network stack for DHCP:
    let mut dhcp_config = DhcpConfig::default();
    dhcp_config.hostname = Some(CONFIG_TOML.hostname.try_into().unwrap());

    let config = embassy_net::Config::dhcpv4(dhcp_config);
    // Init network stack
    let (stack, runner) = embassy_net::new(
        wifi_interface,
        config,
        mk_static!(StackResources<3>, StackResources::<3>::new()),
        net_seed,
    );

    // Spawn parallel tasks
    spawner.spawn(connection(wifi_controller)).unwrap();
    spawner.spawn(net_task(runner)).unwrap();
    spawner
        .spawn(cloud_connection_task(
            stack,
            peripherals.SHA,
            peripherals.RSA,
        ))
        .unwrap();

    // MARK: main loop
    let mut cnt = 0u32;
    let mut angle_bg = None;
    let mut last_stack_link_state = None;
    let mut last_stack_ipv4_addr = None;
    loop {
        //info!("Hello world #{}", cnt);
        Timer::after(Duration::from_millis(40)).await;
        cnt += 20; // 1 turn in 2s

        // progress alike circle/arc
        let angle_start = ((cnt % 360) as f32).deg();
        //let angle_end = angle_start + 30.0.deg();
        let angle_sweep = 100.0.deg();

        if let Some(angle_bg) = angle_bg {
            embedded_graphics::primitives::Arc::new(
                Point::new(25, 32),
                40,
                angle_bg,
                if angle_bg - angle_start < 0.0.deg() {
                    angle_bg - angle_start + 360.0.deg()
                } else {
                    angle_bg - angle_start
                },
            )
            .into_styled(PrimitiveStyle::with_stroke(Rgb565::BLACK, 2))
            .draw(&mut display)
            .unwrap();
        }

        embedded_graphics::primitives::Arc::new(Point::new(25, 32), 40, angle_start, angle_sweep)
            .into_styled(PrimitiveStyle::with_stroke(Rgb565::GREEN, 2))
            .draw(&mut display)
            .unwrap();
        angle_bg = Some(angle_start);

        if let Ok(Some(touches)) = touch_driver.get_touch_data() {
            for (i, touch) in touches.points.iter().enumerate() {
                info!("Touch {}: X: {}, Y: {}", i, touch.x, touch.y);
            }
        }

        // check for wifi link state changes
        let link_state = stack.is_link_up();
        if last_stack_link_state != Some(link_state) {
            info!("Network link state changed: {}", link_state);
            last_stack_link_state = Some(link_state);
        }
        let ipv4_addr = stack.config_v4();
        if last_stack_ipv4_addr != ipv4_addr {
            info!("Network IPv4 address changed: {}", ipv4_addr);
            last_stack_ipv4_addr = ipv4_addr;
        }

        // show list of devices on screen: (only if updates... detect via last_status_update max value)
        if cnt % 1000 == 0 {
            DEVICES.lock(|devices| {
                // clear area:
                let clear_area = Rectangle::new(
                    display.bounding_box().anchor_point(AnchorPoint::BottomLeft)
                        - Point::new(5, 2 + (15 * 6) as i32),
                    Size::new(162, 15 * 6),
                );
                display
                    .fill_solid(&clear_area, Rgb565::CSS_LIGHT_GRAY)
                    .unwrap();

                for device in devices.borrow().iter().enumerate() {
                    //info!("Device {}: {}", device.0, device.1);
                    let text = heapless::format!(40;
                        "HT{}:{:.0}/{:.1}C V{:.0}%",
                        device.0,
                        device.1.set_point_temp,
                        device.1.valve_act_temp,
                        device.1.valve_position*100.0,
                    )
                    .unwrap_or_default();
                    Text::with_alignment(
                        &text,
                        display.bounding_box().anchor_point(AnchorPoint::BottomLeft)
                            - Point::new(5, 5 + (15 * device.0) as i32),
                        character_style,
                        Alignment::Left,
                    )
                    .draw(&mut display)
                    .unwrap();
                }
            });
        }
    }
}

static mut RNG_INSTANCE: Option<Rng> = None;

#[unsafe(no_mangle)]
extern "C" fn random() -> core::ffi::c_ulong {
    unsafe {
        if let Some(ref mut rng) = RNG_INSTANCE {
            rng.random() as core::ffi::c_ulong
        } else {
            0
        }
    }
}

#[derive(Deserialize, Debug)]
struct HmIpGetHostResponse<'a> {
    #[serde(rename = "urlREST")]
    url_rest: &'a str,
    #[serde(rename = "urlWebSocket")]
    url_websocket: &'a str,
}

#[embassy_executor::task]
async fn cloud_connection_task(
    stack: Stack<'static>,
    sha: esp_hal::peripherals::SHA<'static>,
    rsa: esp_hal::peripherals::RSA<'static>,
) {
    info!("task 'cloud_connection_task' running...");

    // determine free heap before TLS init
    info!("Free heap before TLS: {} bytes", esp_alloc::HEAP.free());
    info!("Heap stats before TLS: {:?}", esp_alloc::HEAP.stats());

    let mut tls = esp_mbedtls::Tls::new(sha).unwrap().with_hardware_rsa(rsa);
    tls.set_debug(5);
    //info!("TLS self-test(SHA384) result: {:?}", tls.self_test(esp_mbedtls::TlsTest::Sha384, true));
    //info!("TLS self-test(AES) result: {:?}", tls.self_test(esp_mbedtls::TlsTest::Aes, true));
    info!("ssl_config_check result: {:x}", tls.ssl_config_check());
    let tls_ref = tls.reference();
    // todo do this in a loop with retries and backoff

    // Wait for network to be ready
    loop {
        if stack.is_link_up() {
            if let Some(config) = stack.config_v4() {
                info!("Network ready with IP: {:?}", config.address);
                break;
            }
        }
        Timer::after(Duration::from_millis(500)).await;
    }
    info!("Network is ready, starting cloud connection...");

    // todo connect to homematic ip cloud and get data from there
    // Create buffers for HTTP client (make them static to avoid stack overflow)
    // let rx_buf = mk_static!([u8; 4096], [0; 4096]);
    //let tls_read_buf = mk_static!([u8; 16640], [0; 16640]);
    //let tls_write_buf = mk_static!([u8; 16384], [0; 16384]);

    let config = reqwless::client::TlsConfig::new(
        reqwless::TlsVersion::Tls1_2,
        reqwless::Certificates::default(),
        tls_ref,
    );

    use embassy_net::tcp::client::{TcpClient, TcpClientState};
    let tcp_state = mk_static!(TcpClientState::<1, 16384, 16640>, TcpClientState::new());
    let tcp_client = TcpClient::new(stack, tcp_state);
    let dns_socket = embassy_net::dns::DnsSocket::new(stack);

    let mut client = HttpClient::new_with_tls(&tcp_client, &dns_socket, config);
    info!("HTTP client with TLS initialized");
    info!("Free heap after TLS: {} bytes", esp_alloc::HEAP.free());
    info!("Heap stats after TLS: {:?}", esp_alloc::HEAP.stats());

    let url_rest: RefCell<Option<heapless::String<64>>> = RefCell::new(None);
    let url_websocket: RefCell<Option<heapless::String<64>>> = RefCell::new(None);

    let process_gethost_response = |code, body: &mut [u8]| {
        info!("Processing getHost response with status code {}:", code);
        if let Ok(body_str) = core::str::from_utf8(body) {
            info!("Response body: {}", body_str);
        }
        // todo: unescape needed? can host names contain json escaped chars?
        match serde_json_core::from_slice::<HmIpGetHostResponse>(body) {
            Ok((resp, consumed)) => {
                info!("Parsed JSON response, consumed {} bytes", consumed);
                info!("urlREST: {}", resp.url_rest);
                *url_rest.borrow_mut() = heapless::String::try_from(resp.url_rest).ok();
                info!("urlWebSocket: {}", resp.url_websocket);
                *url_websocket.borrow_mut() = heapless::String::try_from(resp.url_websocket).ok();
                // replace wss: with https:
                if let Some(ref mut url_ws) = *url_websocket.borrow_mut() {
                    if url_ws.starts_with("wss:") {
                        let https_url = heapless::format!(64; "https:{}", &url_ws.as_str()[4..])
                            .unwrap_or_default();
                        *url_ws = https_url;
                        info!("Converted urlWebSocket to HTTPS URL: {}", url_ws);
                    }
                }
            }
            Err(err) => {
                warn!(
                    "Failed to parse JSON response: {}",
                    defmt::Debug2Format(&err)
                );
            }
        };
    };

    let client_characteristics = heapless::format!(400; "{{\"clientCharacteristics\": {{\"apiVersion\": \"10\", \"applicationIdentifier\": \"{}\", \"applicationVersion\": \"{}\", \"deviceManufacturer\": \"{}\", \"deviceType\": \"Computer\", \"language\": \"de_DE\", \"osType\": \"{}\", \"osVersion\": \"{}\"}}, \"id\": \"{}\"}}",
        CONFIG_TOML.hmip_application_identifier,
        CONFIG_TOML.hmip_application_version,
        CONFIG_TOML.hmip_device_manufacturer,
        CONFIG_TOML.hmip_os_type,
        CONFIG_TOML.hmip_os_version,
        CONFIG_TOML.hmip_accesspoint_id).unwrap_or_default();

    let _get_host_res = single_https_request(
        reqwless::request::Method::POST,
        CONFIG_TOML.hmip_lookup_host,
        &[
            ("Content-Type", "application/json"),
            ("Accept", "application/json"),
        ],
        client_characteristics.as_bytes(),
        process_gethost_response,
        &mut client,
    )
    .await;

    // do we have a rest url? then open a session to that one:
    if let Some(url_rest) = &*url_rest.borrow() {
        info!("Got REST URL from getHost: {}", url_rest);
        let process_rest_response = |code, body: &mut [u8]| {
            info!(
                "Processing REST response with status code {}:, body.len(): {}",
                code,
                body.len()
            );
            /*if let Ok(body_str) = core::str::from_utf8(body) {
                info!("Response body: {}", body_str);
            }*/
            // use core_json streaming deserializer
            if let Ok(ref mut des) =
                core_json::Deserializer::<&[u8], core_json::ConstStack<20>>::new(&body[..])
            {
                if let Ok(mut val) = des.value() {
                    if let Ok(core_json::Type::Object) = val.kind() {
                        if let Ok(mut fields) = val.fields() {
                            loop {
                                match fields.next() {
                                    Some(Ok(mut field)) => {
                                        // collect field key:
                                        let key: heapless::String<200> =
                                            field.key().filter_map(|k| k.ok()).collect();
                                        // info!("Field key: {}", key);
                                        match key.as_ref() {
                                            "home" => {
                                                // process home object TODO parse weather, outside temp, expected,...
                                                info!("Processing 'home' object");
                                            }
                                            "devices" => {
                                                // info!("Processing 'devices':");
                                                // iterate over devices: (object keys are device ids)
                                                if let Ok(mut devices) = field.value().fields() {
                                                    while let Some(Ok(mut device)) = devices.next()
                                                    {
                                                        // process each device object
                                                        let mut dev_id: heapless::String<50> =
                                                            device
                                                                .key()
                                                                .filter_map(|k| k.ok())
                                                                .collect();
                                                        info!(
                                                            "Processing 'device' with key: {}",
                                                            dev_id
                                                        );
                                                        if let Ok(mut dev_fields) =
                                                            device.value().fields()
                                                        {
                                                            let mut low_bat: Option<bool> = None; // functionalChannels.0.lowBat
                                                            // todo use functionalChannels.0.unreach|devicePowerFailureDetected?
                                                            let mut last_status_update: Option<
                                                                i64,
                                                            > = None; // .lastStatusUpdate
                                                            let mut label: Option<
                                                                heapless::String<50>,
                                                            > = None; // .label
                                                            let mut valve_position: Option<f64> =
                                                                None; // functionalChannels.1.valvePosition
                                                            let mut set_point_temp: Option<f64> =
                                                                None; // functionalChannels.1.setPointTemperature
                                                            let mut valve_act_temp: Option<f64> =
                                                                None; // functionalChannels.1.valveActualTemperature
                                                            while let Some(Ok(mut dev_field)) =
                                                                dev_fields.next()
                                                            {
                                                                let dev_field_key:heapless::String<100> = dev_field.key().filter_map(|k|k.ok()).collect();
                                                                // info!(" Device field key: {}",dev_field_key);
                                                                // process device fields here...
                                                                match dev_field_key.as_ref() {
                                                                    "id" => {
                                                                        // overwrite dev_key with actual id from field
                                                                        if let Ok(id_str) =
                                                                            dev_field
                                                                                .value()
                                                                                .to_str()
                                                                        {
                                                                            dev_id = id_str
                                                                                .filter_map(|k| {
                                                                                    k.ok()
                                                                                })
                                                                                .collect();
                                                                            info!(
                                                                                "  device id: {}",
                                                                                dev_id
                                                                            );
                                                                        }
                                                                    }
                                                                    "type" => {
                                                                        if let Ok(device_type) =
                                                                            dev_field
                                                                                .value()
                                                                                .to_str()
                                                                        {
                                                                            let dev_type :heapless::String<100> = device_type.filter_map(|k|k.ok()).collect();
                                                                            info!(
                                                                                "  deviceType: {}",
                                                                                dev_type
                                                                            );
                                                                            if !(dev_type.as_str()
                                                                                == "HEATING_THERMOSTAT")
                                                                            {
                                                                                break;
                                                                            }
                                                                        }
                                                                    }
                                                                    "lastStatusUpdate" => {
                                                                        last_status_update =
                                                                            dev_field
                                                                                .value()
                                                                                .to_number()
                                                                                .ok()
                                                                                .and_then(|n| {
                                                                                    n.i64()
                                                                                });
                                                                        info!(
                                                                            "  lastStatusUpdate: {}",
                                                                            last_status_update
                                                                        );
                                                                    }
                                                                    "label" => {
                                                                        if let Ok(label_str) =
                                                                            dev_field
                                                                                .value()
                                                                                .to_str()
                                                                        {
                                                                            label = Some(
                                                                                label_str
                                                                                    .filter_map(
                                                                                        |k| k.ok(),
                                                                                    )
                                                                                    .collect(),
                                                                            );
                                                                            info!(
                                                                                "  label: {}",
                                                                                label
                                                                            );
                                                                        }
                                                                    }
                                                                    "functionalChannels" => {
                                                                        if let Ok(mut channels) =
                                                                            dev_field
                                                                                .value()
                                                                                .fields()
                                                                        {
                                                                            while let Some(Ok(
                                                                                mut channel,
                                                                            )) =
                                                                                channels.next()
                                                                            {
                                                                                let channel_idx:heapless::String<10> = channel.key().filter_map(|k|k.ok()).collect();
                                                                                //info!("   functionalChannel idx: {}",channel_idx);
                                                                                // iterate over channel fields:
                                                                                if let Ok(
                                                                                    mut
                                                                                    channel_fields,
                                                                                ) = channel
                                                                                    .value()
                                                                                    .fields()
                                                                                {
                                                                                    while let Some(Ok(mut channel_field))=channel_fields.next(){
                                                                                        let channel_field_key:heapless::String<100> = channel_field.key().filter_map(|k|k.ok()).collect();
                                                                                        // info!("    channel field key: {}",channel_field_key);
                                                                                        match (channel_idx.as_ref(), channel_field_key.as_ref()){
                                                                                            ("0","lowBat")=>{
                                                                                                if let Ok(b)=channel_field.value().to_bool(){
                                                                                                    low_bat = Some(b);
                                                                                                    info!("     lowBat: {}",low_bat);
                                                                                                }
                                                                                            }
                                                                                            ("1","valvePosition")=>{
                                                                                                valve_position = channel_field.value().to_number().ok().and_then(|n|n.f64());
                                                                                                info!("     valvePosition: {}",valve_position);
                                                                                            }
                                                                                            ("1","setPointTemperature")=>{
                                                                                                set_point_temp = channel_field.value().to_number().ok().and_then(|n|n.f64());
                                                                                                info!("     setPointTemperature: {}",set_point_temp);
                                                                                            }
                                                                                            ("1","valveActualTemperature")=>{
                                                                                                valve_act_temp = channel_field.value().to_number().ok().and_then(|n|n.f64());
                                                                                                info!("     valveActualTemperature: {}",valve_act_temp);
                                                                                            }
                                                                                            _=>{
                                                                                                // info!("     Ignoring channel {} key: {}",channel_idx, channel_field_key);
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    _ => {
                                                                        // info!("  Ignoring device field key: {}",dev_field_key);
                                                                    }
                                                                }
                                                            }
                                                            // check if we have all mandatory fields for a heating thermostat device here...
                                                            if let (
                                                                Some(last_status_update),
                                                                Some(low_bat),
                                                                Some(label),
                                                                Some(valve_position),
                                                                Some(set_point_temp),
                                                                Some(valve_act_temp),
                                                            ) = (
                                                                last_status_update,
                                                                low_bat,
                                                                label,
                                                                valve_position,
                                                                set_point_temp,
                                                                valve_act_temp,
                                                            ) {
                                                                // all fields present, create/update device entry
                                                                let heating_thermostat =
                                                                    HeatingThermostat {
                                                                        id: dev_id,
                                                                        label,
                                                                        last_status_update,
                                                                        low_bat,
                                                                        valve_position,
                                                                        set_point_temp,
                                                                        valve_act_temp,
                                                                    };
                                                                info!(
                                                                    "  Created HeatingThermostat device: {}",
                                                                    heating_thermostat
                                                                );
                                                                // store in global devices list:
                                                                DEVICES.lock(|devices|{
                                                                    let mut devices = devices.borrow_mut();
                                                                    if let Some(pos) = devices.iter().position(|d| d.id == heating_thermostat.id) {
                                                                        devices[pos] = heating_thermostat;
                                                                        info!("  Updated existing device in DEVICES list");
                                                                    } else {
                                                                        if devices.push(heating_thermostat).is_ok() {
                                                                            info!("  Added new device to DEVICES list");
                                                                        } else {
                                                                            warn!("  DEVICES list full, cannot add new device");
                                                                        }
                                                                    }
                                                                });
                                                            } else {
                                                                info!(
                                                                    "  Missing mandatory fields device {}. ignoring.",
                                                                    dev_id
                                                                );
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            "clients" | "groups" => {}
                                            _ => {
                                                // clients, groups
                                                warn!("Ignoring field key: {}", key);
                                            }
                                        }
                                    }
                                    Some(Err(e)) => {
                                        warn!(
                                            "Error iterating field: {:?}",
                                            defmt::Debug2Format(&e)
                                        );
                                        // dont break;
                                    }
                                    None => {
                                        break;
                                    }
                                }
                            }
                        }
                        // iterate over the fields: (expect home, groups, devices, clients)
                    }
                } else {
                    warn!("Failed to parse first JSON value");
                }
            } else {
                warn!("Failed to create core_json deserializer");
            }
        };

        // add /hmip/home/getCurrentState
        let mut url = url_rest.clone();
        url.push_str("/hmip/home/getCurrentState").unwrap();
        info!("Full REST URL for getCurrentState: {}", url);
        let _rest_res = single_https_request(
            reqwless::request::Method::POST,
            &url,
            &[
                ("Content-Type", "application/json"), // ("Accept", "application/json"),
                ("VERSION", "12"),                    // todo is 12 from the response from getHost?
                ("AUTHTOKEN", CONFIG_TOML.hmip_authtoken),
                ("CLIENTAUTH", CONFIG_TOML.hmip_clientauth),
                ("ACCESSPOINT-ID", CONFIG_TOML.hmip_accesspoint_id),
            ],
            client_characteristics.as_bytes(), // br#"{"clientCharacteristics": {"apiVersion": "10", "applicationIdentifier": "homematicip-python", "applicationVersion": "1.0", "deviceManufacturer": "none", "deviceType": "Computer", "language": "de_DE", "osType": "Darwin", "osVersion": "25.0.0"}, "id": "3014F711A000506269927DA4"}"#.as_slice(),
            process_rest_response,
            &mut client,
        )
        .await;
    } else {
        warn!("No REST URL obtained from getHost, cannot proceed");
    }

    if let Some(url_websocket) = &*url_websocket.borrow() {
        // open websocket connection to url_websocket
        let _ws_res = websocket_connection(
            url_websocket,
            &[
                ("AUTHTOKEN", CONFIG_TOML.hmip_authtoken),
                ("CLIENTAUTH", CONFIG_TOML.hmip_clientauth),
                ("ACCESSPOINT-ID", CONFIG_TOML.hmip_accesspoint_id),
                ("Upgrade", "websocket"),
                ("Connection", "Upgrade"),
                ("Sec-WebSocket-Version", "13"),
                ("Sec-WebSocket-Key", "dGhlIHNhbXBsZSBub24jZQ=="), // TODO make dynamic!
            ],
            &mut client,
        )
        .await;
    } else {
        warn!("No WebSocket URL obtained from getHost, cannot proceed");
    }

    /* in header_buf:
    HTTP/1.1 200 OK
    Server: Apache-Coyote/1.1
    Set-Cookie: JSESSIONID=FAD164160D2DFC19F18E2A2F2C5E90ED; Path=/; Secure; HttpOnly
    X-Application-Context: application
    Content-Type: application/json;charset=UTF-8
    Content-Length: 223
    Date: Sun, 26 Oct 2025 10:02:34 GMT
     */
    info!("end cloud_connection_task");
}

async fn websocket_connection<'a, T, D>(
    url: &str,
    headers: &[(&str, &str)],
    client: &mut HttpClient<'a, T, D>,
) -> Result<(), reqwless::Error>
where
    T: embedded_nal_async::TcpConnect,
    D: embedded_nal_async::Dns,
{
    info!("Starting websocket connection to '{}'", url);
    info!("Free heap: {} bytes", esp_alloc::HEAP.free());

    // perform a regular https request with Upgrade: websocket header
    // then use the HttpConnection to read/write websocket frames
    let resource = client.resource(url).await;
    if let Ok(mut resource) = resource {
        // conn = resource.conn;
        info!("Websocket resource created");
        // TODO heartbeat = 30
        let empty_body: &[u8] = &[];
        let request = resource
            .request(reqwless::request::Method::GET, "/")
            .headers(headers)
            .body(empty_body);
        info!("Websocket request prepared, sending...");
        {
            let mut rx_buffer = [0_u8; (16 * 1024)];
            let response = request.send(&mut rx_buffer).await.unwrap();
            {
                let headers = &response
                    .headers()
                    .filter(|(k, _)| !k.is_empty())
                    .collect::<heapless::Vec<_, 128>>();
                info!(
                    "Websocket request sent, response status: {}, content_length: {}, headers: {:?}",
                    response.status,
                    response.content_length.unwrap_or(0),
                    headers
                );
            }
            // we expect a status code 101 (and no body)
            if let Ok(body) = response.body().read_to_end().await {
                if let Ok(body_str) = core::str::from_utf8(body) {
                    info!("Response body: {}", body_str);
                }
            }
        }

        let mut ws_client = embedded_websocket::WebSocketClient::new_client(Rng::new()); // TODO use this key and not the static one!
        ws_client.state = embedded_websocket::WebSocketState::Open; // we did the handshake already...
        info!("Free heap with ws_client: {} bytes", esp_alloc::HEAP.free());
        // send a ping frame:

        Timer::after(Duration::from_secs(2)).await;
        let mut tx_buffer = heapless::Vec::<u8, 10>::new();
        let _ = tx_buffer.resize_default(10);
        let len = ws_client
            .write(
                embedded_websocket::WebSocketSendMessageType::Ping,
                true,
                b"", // .as_bytes(),
                &mut tx_buffer,
            )
            .unwrap();
        let written =
            esp_mbedtls::asynch::io::Write::write(&mut resource.conn, &tx_buffer[..len]).await?;
        esp_mbedtls::asynch::io::Write::flush(&mut resource.conn).await?;
        info!(
            "Sent ping frame len {}, wrote {} bytes to websocket connection: {:?}",
            len,
            written,
            defmt::Debug2Format(&tx_buffer[..written])
        );

        // loop until connection closed
        // TODO: most frames are a lot smaller (7kb, 10kb), ignore big ones... 
        let mut frame_buffer = heapless::Vec::<u8, { 80 * 1024 }>::new(); // lets hope the events fit into 80kb
        frame_buffer.resize_default(80 * 1024).unwrap();
        let mut frame_buffer_used = 0usize;

        let mut rx_buffer = heapless::Vec::<u8, 4096>::new();
        rx_buffer.resize_default(4096).unwrap();
        let mut rx_buffer_used = 0usize;
        loop {
            match select(
                esp_mbedtls::asynch::io::Read::read(
                    &mut resource.conn,
                    &mut rx_buffer[rx_buffer_used..],
                ),
                Timer::after(Duration::from_secs(15)),
            )
            .await
            {
                Either::First(Ok(read)) => {
                    info!(
                        "Read {}+{} bytes from websocket connection",
                        rx_buffer_used, read
                    );
                    if read > 0 || rx_buffer_used > 0 {
                        // todo better logic for fragmented frames! (loop before read from socket?)
                        rx_buffer_used += read;
                        match ws_client.read(
                            &rx_buffer[..rx_buffer_used],
                            &mut frame_buffer[frame_buffer_used..],
                        ) {
                            Ok(frame) => {
                                rx_buffer_used = if frame.end_of_message {
                                    // need to move the rest of the buffer to the front
                                    rx_buffer.copy_within(frame.len_from..rx_buffer_used, 0);
                                    rx_buffer_used.saturating_sub(frame.len_from)
                                } else {
                                    0
                                };
                                info!(
                                    "Received websocket, new rx_buffer_used={} frame: {}",
                                    rx_buffer_used,
                                    defmt::Debug2Format(&frame)
                                );
                                match frame.message_type {
                            embedded_websocket::WebSocketReceiveMessageType::Text => {
                                frame_buffer_used += frame.len_to as usize;
                                if frame.end_of_message {
                                    if let Ok(text) = core::str::from_utf8(&frame_buffer
                                        [..frame_buffer_used ])
                                    {
                                        info!(" Websocket Text message: {}", text);
                                    } else {
                                        warn!(" Websocket Text message not valid UTF-8");
                                    }
                                    frame_buffer_used = 0;
                                }
                            }
                            embedded_websocket::WebSocketReceiveMessageType::Binary => {
                                frame_buffer_used += frame.len_to as usize;
                                if frame.end_of_message {
                                    // complete message received
                                    // DEVICE_CHANGED 7kb: {"events":{"0":{"pushEventType":"DEVICE_CHANGED","device":{"id":"3014F
                                    info!(
                                        " Complete binary message received, total length {} bytes",
                                        frame_buffer_used
                                    );
                                    // process message in frame_buffer[..frame_buffer_used] here...
                                    if let Ok(text) = core::str::from_utf8(&frame_buffer[..frame_buffer_used])
                                    {
                                        info!(" Websocket Binary message: {}", text);
                                    } 
                                    // for now just reset buffer:
                                    frame_buffer_used = 0;
                                }
                            }
                            embedded_websocket::WebSocketReceiveMessageType::Ping => {
                                info!(" Websocket Ping message"); // should never come from the server...?
                                // respond with Pong
                                let len = ws_client
                                    .write(
                                        embedded_websocket::WebSocketSendMessageType::Pong,
                                        true,
                                        b"", // .as_bytes(),
                                        &mut tx_buffer,
                                    )
                                    .unwrap();
                                let _ = esp_mbedtls::asynch::io::Write::write(
                                    &mut resource.conn,
                                    &tx_buffer[..len],
                                ).await?;
                            }
                            embedded_websocket::WebSocketReceiveMessageType::Pong => {
                                info!(" Websocket Pong message");
                                frame_buffer_used = 0;
                            }
                            embedded_websocket::WebSocketReceiveMessageType::CloseMustReply | embedded_websocket::WebSocketReceiveMessageType::CloseCompleted => {
                                info!(" Websocket Close message");
                                break;
                            }
                        }
                            }
                            Err(e) => {
                                warn!(
                                    "Failed to parse websocket frame: {:?} {:?}",
                                    defmt::Debug2Format(&e),
                                    defmt::Debug2Format(&rx_buffer[..rx_buffer_used])
                                );
                                if read == 0 {
                                    // no more data to read, might have garbage?
                                    rx_buffer_used = 0;
                                }
                            }
                        }
                    } else {
                        // check whether conn is closed: HOW? assume on read 0?
                        // wait a bit before next read
                        Timer::after(Duration::from_secs(2)).await;
                    }
                }
                Either::First(Err(e)) => {
                    warn!(
                        "Error reading from websocket connection: {:?}",
                        defmt::Debug2Format(&e)
                    );
                    break;
                }
                Either::Second(_) => {  
                    //warn!("Timeout waiting for data from websocket connection");
                    // send a ping
                    let len = ws_client
                        .write(
                            embedded_websocket::WebSocketSendMessageType::Ping,
                            true,
                            b"", // .as_bytes(),
                            &mut tx_buffer,
                        )
                        .unwrap();
                    let written =
                        esp_mbedtls::asynch::io::Write::write(&mut resource.conn, &tx_buffer[..len]).await?;
                    esp_mbedtls::asynch::io::Write::flush(&mut resource.conn).await?;
                    info!(
                        "Sent ping frame len {}, wrote {} bytes to websocket connection: {:?}",
                        len,
                        written,
                        defmt::Debug2Format(&tx_buffer[..written])
                    );
                }
            };

            /*
            let read = esp_mbedtls::asynch::io::Read::read(
                &mut resource.conn,
                &mut rx_buffer[rx_buffer_used..],
            )
            .await?;*/
        }
        info!("Websocket connection handling done.");
    } else {
        warn!("Failed to create resource for websocket URL");
    }

    Ok(())
}

async fn single_https_request<'a, T, D>(
    method: reqwless::request::Method,
    url: &str,
    headers: &[(&str, &str)],
    body: &[u8],
    mut process_response_cb: impl for<'cb> FnMut(reqwless::response::StatusCode, &mut [u8]) + 'a,
    client: &mut HttpClient<'a, T, D>,
) -> Result<(), reqwless::Error>
where
    T: embedded_nal_async::TcpConnect,
    D: embedded_nal_async::Dns,
{
    info!("Performing single HTTPS {} request to '{}'", method, url);
    info!("Free heap: {} bytes", esp_alloc::HEAP.free());

    match client.request(method, url).await {
        Ok(request) => {
            info!("HTTP request created");
            info!("Free heap after request: {} bytes", esp_alloc::HEAP.free());
            let mut request = request.headers(headers).body(body);
            info!("HTTP request prepared, sending...");
            let mut rx_buffer = [0_u8; (100 * 1024)];
            let response = request.send(&mut rx_buffer).await.unwrap();
            info!(
                "HTTP request sent, response status: {}, content_length: {}",
                response.status,
                response.content_length.unwrap_or(0)
            );
            // info!("HTTP response: {}", response);
            // we might want to set our clock based on the Date: header in the response!

            // todo process only if http 200, content length reasonably small (<1kb), ...
            let code = response.status;
            if let Ok(body) = response.body().read_to_end().await {
                process_response_cb(code, body);
            } else {
                warn!("Failed to read response body");
            }
        }
        Err(e) => {
            // todo handle errors properly, esp the ones that can occur during lifetime like cert changes
            // -9984 = -0x2700 MBEDTLS_ERR_X509_CERT_VERIFY_FAILED
            // -24960 = -0x6180 MBEDTLS_ERR_CIPHER_ALLOC_FAILED
            warn!("Failed to create HTTP request: {:?}", e);
            return Err(e);
        }
    }
    Ok(())
}

#[embassy_executor::task]
async fn connection(mut controller: WifiController<'static>) {
    info!("task 'connection' running...");
    info!("Device capabilities: {:?}", controller.capabilities());
    loop {
        match controller.is_connected() {
            Ok(true) => {
                // info!("Already connected to wifi");
                Timer::after(Duration::from_secs(2)).await;
                continue;
            }
            Ok(false) => {}
            Err(e) => {
                warn!("Failed to get wifi connection state: {:?}", e);
                Timer::after(Duration::from_millis(3000)).await;
                continue;
            }
        }

        // not connected, check whether controller is started:
        if !matches!(controller.is_started(), Ok(true)) {
            let client_config = ModeConfig::Client(
                ClientConfig::default()
                    .with_ssid(CONFIG_TOML.wifi_ssid.try_into().unwrap())
                    .with_password(CONFIG_TOML.wifi_password.try_into().unwrap()),
            );
            controller.set_config(&client_config).unwrap();
            info!("Starting wifi");
            controller.start_async().await.unwrap();
            info!("Wifi started!: {:?}", controller.is_started());
        }
        info!("About to connect...");

        match controller.connect_async().await {
            Ok(_) => info!("Wifi connected!"),
            Err(e) => {
                info!("Failed to connect to wifi: {:?}", e);
                Timer::after(Duration::from_millis(5000)).await
            }
        }
    }
    //info!("end connection task");
}

#[embassy_executor::task]
async fn net_task(mut runner: Runner<'static, WifiDevice<'static>>) {
    info!("task 'net_task' running...");
    runner.run().await;
    //info!("end net_task");
}
